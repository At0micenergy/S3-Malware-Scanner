# S3-Malware-Scanner
Malware Scanner for AWS S3-Bucket
The automated malware scanner leverages AWS serverless architecture, primarily utilizing AWS Lambda functions for event-driven processing. When a user or developer uploads files to the AWS S3 bucket, an AWS Lambda function is triggered. This Lambda function initiates a Docker container running the ClamAV antivirus engine. The Python code within the container interacts with the S3 API to retrieve and scan the uploaded objects. Depending on the scan results, two pathways are implemented: if malware is detected, the file is isolated, and an alert is triggered through AWS CloudWatch; if the file is clean, it is released for production use. The alert is then sent via AWS Simple Notification Service (SNS) to relevant stakeholders

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/21b7d2b9-9548-4d29-a1e7-f82d0b5faf98)

As the entire project is implemented in AWS Cloud, the following are the components we utilized:
•	S3 Buckets
•	AWS Lambda
•	Elastic Container Registry
•	Amazon CloudWatch
•	AWS Simple Notification Service (SNS)
•	Custom ClamAV Docker images

Docker image is employed to package the ClamAV antivirus engine and Python code within a container. Docker provides a portable and isolated environment, ensuring consistent execution across diverse computing environments. This containerization enables easy transferability, allowing the deployment of the malware scanner seamlessly across various AWS instances.  The ease of pulling and deploying Docker images streamlines the integration of ClamAV within the AWS Lambda environment. Overall, Docker enhances the reproducibility, portability, and scalability of the malware scanning solution in this project

CloudWatch AWS is a monitoring and observability service that collects and tracks performance data, log files, and events, providing insights into the operational health of AWS resources. In this project, CloudWatch plays a pivotal role by capturing lambda logs from the automated malware scanner, enabling real-time monitoring of file scanning performance and resource utilization. Configured alarms in CloudWatch promptly detect malware events, triggering immediate notifications through AWS SNS. This contribution enhances the project's incident response capabilities, allowing for swift and proactive actions upon malware detection. The seamless integration of CloudWatch with AWS Lambda ensures efficient monitoring of the scanning process, aiding in the maintenance of a secure AWS S3 bucket environment. CloudWatch's comprehensive monitoring features contribute to the overall effectiveness and security of the automated malware scanner deployment

AWS Simple Notification Service (SNS) is a fully managed messaging service that enables the distribution of messages to a distributed set of recipients, including individuals, applications, and other services. In this project, SNS plays a crucial role by providing immediate notifications when the automated malware scanner detects malicious content in AWS S3 buckets. Its seamless integration with other AWS services, such as AWS CloudWatch, facilitates quick and efficient alerting, allowing stakeholders to respond promptly to security incidents. SNS ensures reliable and scalable communication, contributing to the real-time incident response capabilities of the automated malware scanner

AWS ECR is fully managed container registry, ensuring secure storage, management, and high-performance deployment of Docker container images. In our project, we leverage ECR to securely store and manage the Docker image for our automated malware scanner. ECR's native integration with AWS Lambda streamlines the deployment process, providing low-latency access and fine-grained IAM control for image security. 

AWS Lambda is a serverless computing service that allows developers to run code without provisioning or managing servers. It supports multiple programming languages and executes functions in response to events, such as changes to data in an Amazon S3 bucket or updates to a DynamoDB table. With Lambda, users pay only for the compute time consumed during the code execution, and it automatically scales based on demand. The service simplifies application development by handling the underlying infrastructure, ensuring high availability and fault tolerance. Lambda functions can be easily integrated with other AWS services, enabling the creation of efficient and scalable serverless architectures.

In this project, AWS Lambda is chosen for its serverless architecture, simplifying development by automatically managing infrastructure. Its event-driven model aligns seamlessly with scanning files upon S3 uploads. Lambda's pay-as-you-go pricing offers cost efficiency for intermittent workloads, and its automatic scaling ensures responsiveness to varying demand. This choice minimizes operational overhead, streamlining deployment compared to managing containers on Amazon Elastic Container Registry (ECR) or virtual machines on Amazon Elastic Compute Cloud (EC2). While EC2 and ECR provide more control over infrastructure, Lambda's serverless approach suits the project's requirements for simplicity, cost-effectiveness, and scalability

2.Implementation 

2.1 Creating the ClamAV Docker Image 	
The image will run within the AWS Lambda function, and there are no input parameters required for the Lambda function when executing the Docker image. The entire code is deployed within the Lambda environment.

When constructing the Docker image, two essential components must be considered: the Python application and the Docker base code. The Python application contains the functionality for scanning files in the S3 bucket using ClamAV. The Docker base code is responsible for building the Docker image, ensuring the proper configuration and dependencies are included in the image.

Building the image requires both the app.py file, which contains the Python application responsible for scanning files in the S3 bucket using ClamAV, and the Docker file that specifies the instructions for building the Docker image, ensuring that the necessary dependencies and configurations are included. Together, these components enable the creation of a functional and deployable Docker image for the automated malware scanner within the AWS Lambda environment

```
Docker file 
# Use the Ubuntu base image
FROM ubuntu:latest 
# Set the working directory to /app
WORKDIR /app
# Update and install necessary packages
RUN apt-get update && \
    apt-get install -y clamav python3 python3-pip && \
    pip3 install boto3 
# Set AWS environment variables
ENV AWS_ACCESS_KEY_ID="<>"
ENV AWS_SECRET_ACCESS_KEY="<>"
ENV AWS_DEFAULT_REGION="us-east-1"
# Update ClamAV virus definitions when the container is built
RUN freshclam
# Copy your Python application code (app.py) into the container
COPY app.py /app
# Set the entry point for your application
CMD ["python3", "app.py"]
```

The provided Dockerfile starts by selecting the latest Ubuntu base image. It then sets the working directory to /app within the container, updating and installing essential packages including ClamAV and Python3 Boto3, the AWS SDK for Python, is installed using pip3. AWS credentials and the default region are set as environment variables. ClamAV virus definitions are updated during the image build, and the final configuration copies the local app.py file into the container's /app directory. The Dockerfile concludes by defining the entry point as running the Python application using the CMD directive.

2.2 Building the app.py 
This Python script leverages the AWS SDK (Boto3) to create an automated malware scanner for files stored in an AWS S3 bucket. The script defines functions to update ClamAV virus definitions and scan/upload files based on their virus scan results. The scan_and_process_file function downloads files from a default S3 bucket, conducts a ClamAV scan, and then moves them to either a "ready-to-use" bucket or an "infected" bucket, depending on the scan results. The script iterates through objects in the default bucket, invoking the scan function for each file. The main function serves as the entry point, orchestrating the overall scanning process. Upon execution, the script ensures that infected files are isolated and deleted from the default bucket, while clean files are moved to a designated "ready-to-use" bucket, enhancing the security posture of the AWS S3 environment

```
#Import necessary libraries
import os
import boto3
import subprocess
 
# Initialize the AWS S3 client
s3 = boto3.client('s3')
default_bucket = 'default-bucket-for-scanning'
infected_bucket = 'isolated-bucket-from-malware'
ready_to_use_bucket = 'ready-to-use'
 
# Path to ClamAV executable
clamav_path = '/usr/bin/clamscan'
def update_clamav_definitions():
    try:
        subprocess.run(['freshclam'], check=True)
    except subprocess.CalledProcessError as e:
        print(f"ClamAV definitions update failed: {e}")
        raise
 
# Define a function to scan and process a file
def scan_and_process_file(object_key):
    # Download the file from the default bucket
    local_file = '/tmp/' + object_key
    print(f"Downloading {object_key} from {default_bucket}...")
    s3.download_file(default_bucket, object_key, local_file)
    print(f"Downloaded {object_key} to {local_file}")
    # Perform a ClamAV scan on the downloaded file
    print(f"Scanning {object_key} for viruses...")
    result = subprocess.run([clamav_path, local_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    print(f"Scan result: Return code - {result.returncode}")
    print("Scan output:")
    print(result.stdout.decode('utf-8'))  
    print("Scan errors:")
    print(result.stderr.decode('utf-8')) 
    if result.returncode == 0:
        # No virus found, move the file to the ready-to-use bucket
        print(f"No virus found in {object_key}. Moving to {ready_to_use_bucket}...")
        s3.upload_file(local_file, ready_to_use_bucket, object_key)
        s3.delete_object(Bucket=default_bucket, Key=object_key)
        print(f"Moved {object_key} to {ready_to_use_bucket}")
    else:
        # Virus detected, move the file to the infected bucket and delete from the default bucket
        print(f"Virus detected in {object_key}. Moving to {infected_bucket} and deleting from {default_bucket}...")
        s3.upload_file(local_file, infected_bucket, object_key)
        s3.delete_object(Bucket=default_bucket, Key=object_key)
        print(f"Moved {object_key} to {infected_bucket} and deleted from {default_bucket}")
    # Clean up the local file
    os.remove(local_file)
    print(f"Cleaned up {local_file}")
# Define the main function to scan and process objects in the default bucket
def main():
    # List objects in the default bucket
    response = s3.list_objects(Bucket=default_bucket)
    for obj in response.get('Contents', []):
        object_key = obj['Key']
        print(f"Processing {object_key}...")
        scan_and_process_file(object_key)
        print(f"Processed {object_key}")
# Entry point: execute the main function when the script is run
if __name__ == '__main__':
    main()
```

2.3 Building & running the image locally 
Ensuring that the Docker image runs correctly and provides the expected results involves the following steps
Building the image 	
```
docker build -t scanning-image:latest .
```
Running the docker image 
```
docker run scanning-image:latest
```
Now that it is functioning correctly locally, let us proceed to push the Docker image to Amazon Elastic Container Registry (ECR) since the Lambda function utilizes an ECR image for execution.

2.4 Pushing docker to ECR

Create a repository in Amazon ECR 

Navigate to Elastic Container Registry - Create Repository (amazon.com) provide a name for the repository

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/5214a975-205e-4559-b6a1-451ee9c45715)
 
Click on create, it will create the repository  

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/0734684f-1d63-4f73-83b1-374a8ebf5a0b)
 
When created, ECR provides a URI ID that can be used to push the Docker image from a local machine and can also be utilized in AWS Lambda to execute the docker image from ECR 
 Tag the Docker Image:

Tag the local Docker image with the ECR repository URI. Use this command, replacing
 <AWS_ACCOUNT_ID>, <REGION>, and <REPOSITORY_NAME> with your AWS account ID, preferred region, and the desired repository name :
 
 ```
Docker tag malware-scanner:latest <AWS_ACCOUNT_ID>.dkr.ecr
<REGION>.amazonaws.com/<REPOSITORY_NAME>:latest
```
Push Docker Image to ECR:
Push the tagged Docker image to your ECR repository using the following command:

```
docker push <AWS_ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/<REPOSITORY_NAME>:latest
```

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/c5b31433-c981-47d8-a1e9-6af6d0f45a5e)

 2.3 Lamda Configuration 
Here we’re using the docker image option, so when the event triggered the lambda will call the docker image for execution 

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/5beabeec-9daf-420a-85d8-08a509e6bd4f)

Select the image that is uploaded

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/3bc9698b-bd34-4640-87b3-e6ff1bd0a647)

In AWS, services follow a shared responsibility model. To establish secure interactions between services, users must define and enforce access controls using AWS Identity and Access Management (IAM) policies. In our project, the Docker image requires permission to access the S3 bucket, and Lambda needs authorization to interact with ECR. Thus, it is crucial to define and attach IAM policies to the Lambda function to grant the necessary access, ensuring the seamless execution of the Lambda function without encountering errors

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/42bc965a-c969-4f21-b841-d47f1fe2dd18)

Create the policy and attach it to the role and assign it to the lambda function 

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/9897b08d-4c19-4817-b3e9-8daf6067fd9a)
 
Given that Lambda functions are event-driven, it is necessary to configure a trigger to invoke the function. In this implementation, we are designating the S3 bucket as the trigger object. For the event type, we specifically assign the PUT method. Consequently, whenever a user uploads files to the bucket, the Lambda function is triggered and invoked. 

 ![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/950d6907-07b2-47b9-9446-cd64f46cf4e2)

 ![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/082b71c2-a2ee-44a1-ab0a-bd3f373ba7d4)

Important adjustments need to be made to the CPU, memory, and disk space allocations for the execution of the Lambda function. Additionally, careful consideration should be given to configuring an appropriate timeout value, ensuring sufficient time for the function to complete its tasks while avoiding unnecessary delays

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/e7c679a8-732f-4549-b421-f6bf5705f43a)

2.4 Creating the Alert 
Every Lambda function generates log streams, and this log data can be utilized to populate CloudWatch Metrics. 

CloudWatch Metrics play a crucial role by capturing and analyzing log streams generated by the Lambda function. By creating log filters tailored to the behavior of our automated malware scanner, we can set up alerts based on specific conditions, such as the detection of malicious content in S3 buckets. This proactive alerting mechanism ensures that the security of our AWS environment is promptly monitored, and any potential threats are addressed in a timely manner. The integration of log data into CloudWatch Metrics enhances our ability to maintain a secure and resilient system, aligning with the project's core objective of automated malware detection and response 
 
![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/f7962270-a63a-4a37-8819-1834b3c5ed1a)

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/3df55438-22a7-454a-a899-db2e629de169)

The CloudWatch Metric Filter, named Malware Detection, is configured to capture log events related to malware detections. The filter is set to trigger when the waiting time exceeds 0, indicating a positive malware detection. To ensure timely response, this metric condition is integrated into a CloudWatch Alarm, which notifies designated users or teams when the threshold condition is met. This setup allows for real-time monitoring of malware detection events and swift alerting in case of potential incidents. Adjustments to the static value and conditions can be made based on project requirements
 
![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/bde5d6d1-b93b-4ddb-a139-35065eda2f40)

Here can create the SNS Service to send the alerts real time, just need to add the description and the email end point and save the alert 

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/8c7f7ea5-00fb-4851-b967-1fe89dd40d8f)

Configuring the body for the alert 

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/90abf6b9-ad9a-49de-b028-fafcd8084351)

The overview alerts 

Uploading the files to s3 bucket 

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/3c3258c1-430c-4f10-bac8-dd97506fd3e2)

Testing the Application 

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/a1f4bedd-80d0-4ddf-9557-eb8ffed466bd)

Checking the results 

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/5db65bd9-4407-4beb-870b-73a256702a11)


Can checking the bucket, the infected file is moved to isolated bucket whereas non infected file was moved to read-to-use bucket

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/36c72337-fcc4-4191-b9a6-b97505f95baa)

![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/3022b9ac-f265-4be2-8316-9ac484a593cc)

Reviewing the alert, it indicates that AWS has detected malware.
 
![image](https://github.com/At0micenergy/S3-Malware-Scanner/assets/73755168/6b0f561c-645f-4627-8b18-ae51b827dc42)

3.Conclusion

In conclusion, this project has successfully implemented an automated malware scanner in the AWS Cloud environment. Leveraging AWS Lambda, Docker, S3 buckets, and CloudWatch Metrics, the system monitors and scans files for potential malware upon upload. The integration of CloudWatch Alarms enhances proactive threat detection, ensuring timely alerts in the event of malicious content. By combining these AWS services, the project achieves a robust and scalable solution for safeguarding data integrity within S3 buckets. Continuous monitoring and alerting mechanisms empower users to respond promptly to security incidents, contributing to a more resilient and secure cloud infrastructure.

4.Resources 
https://docs.aws.amazon.com/lambda/latest/dg/images-create.html 
https://boto3.amazonaws.com/v1/documentation/api/latest/index.html 
https://www.vx-underground.org/#E:/root 
https://docs.aws.amazon.com/ 

